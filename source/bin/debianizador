#!/bin/bash


# debianizador 
# Version: 1.5
# Author: monon


SCRIPT_NAME=$(basename ${0})
SRC="/source"
CONTROL_FILE="./debian/control"
WORKING_DIR=""
BUILD_PREFIX=""
BUILD_DEST_DIR=""

EXIT=""
GLOBAL_YES=""
CLEAN=""
REMOVE=""

[[ -e ${HOME}/.bash_colors ]] && source ${HOME}/.bash_colors



function check_user()
{
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: User ${USER}"
    if [[ ${UID} = "0" ]] ; then 
        echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Run \"debianizador\" script as normal user"
        exit 2
    fi
}


function set_working_directory()
{
    echo
    WORKING_DIR=${1}
    if [[ -n "${WORKING_DIR}" ]] ; then
        if [[ -d "${WORKING_DIR}" ]] ; then
            echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Working directory\n  ${WORKING_DIR}"
            cd ${WORKING_DIR}
        else
            echo -e"${RED}${SCRIPT_NAME}${NORMAL}: The directory"
            echo -e "    ${WORKING_DIR}"
            echo -e "does not exist."
            exit 1
        fi
    else
        echo -ne "${RED}${SCRIPT_NAME}${NORMAL}:"
        echo -e "It is mandatory directory with a project and a DEBIAN folder."
        echo -e "Run ${SCRIPT_NAME} -h to show help message"
        exit 1
    fi
}

# if SOURCE exists
function check_sources()
{
    echo
    if [[ -e "${SOURCE_DIR}${SRC}"  ]] ; then
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Source directory:\n  ${SOURCE_DIR}${SRC}"
    else
        echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Directory ${SRC} does not exist into"
        echo -e "    ${SOURCE_DIR}"
        echo
        exit 2
    fi
}


function check_control_file()
{
    local input_read
    echo
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Checking control file"
    if [[ ! -d "./debian" ]] ; then
        echo
        echo -e "${RED}${SCRIPT_NAME}${NORMAL}: A \"debian\" folder with a control file is mandatory"
        echo -ne "Do you want to create \"debian\" folder? [y/N]:"
        input_read=''
        read -sn1 input_read
        echo
        if [[ "${input_read}" =~ ^[Yy]$ ]] ; then
            mkdir -p "${WORKING_DIR}/debian"
        else
            echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Exiting"
            exit 1
        fi
    fi

    ## Checking if control file is into /working_directory/debian folder
    if [[ ! -e "${CONTROL_FILE}" ]]  || [[ -z $(cat "${CONTROL_FILE}") ]] ; then
        echo
        echo  -e "${RED}${SCRIPT_NAME}${NORMAL}: You must to create a control file"
        echo -ne "Do you want to create a \"control\" file? [y/N]:"
        input_read=''
        read -sn1 input_read
        echo
        if [[ "${input_read}" =~ ^[Yy]$ ]] ; then
            create_control_file
        else
            echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Exiting"
            exit 1
        fi
    else  ## If control file exists it will be formated
        echo
        # Formating control file
        (sed -i -e "/^[[:space:]]*$/d" \
        -e "/Description:/,/^$/ {s# *\([[:alnum:]]\+\)# \1#}" \
        -e "s/^ *\(Package:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Version:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Section:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Priority:\) *\([[:alnum:]]*\)/\1 \2/"  \
        -e "s/^ *\(Architecture:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Depends:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\([[:alnum:]]\+:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e '$a\' ${CONTROL_FILE} \
        && ( [[ -s "${CONTROL_FILE}"  ]] && echo -e "Formating \"control\" file")) \
        || (echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Formating \"control\" file" && exit 1)
    fi
    echo
}


function create_control_file()
{
    local package_name=$(basename "${SOURCE_DIR}")
    touch "${CONTROL_FILE}"
    chmod 664 "${CONTROL_FILE}"
    echo -e "Package: ${package_name}" >> ${CONTROL_FILE}
    echo -e "Version: (i.e. 1.0-1)" >> ${CONTROL_FILE}
    echo -e "Section: (admin|..|devel|games|sound|...)"  >> ${CONTROL_FILE}
    echo -e "Priority: (required|important|standart|optional|extra)" >> ${CONTROL_FILE}
    echo -e "Architecture: (all|i386|amd64|...)" >> ${CONTROL_FILE}
    echo -e "Depends: (foo (>= 1.5.0), bar | baz, qux)" >> ${CONTROL_FILE}
    echo -e "Maintainer: Juan Ramon Castan" >> ${CONTROL_FILE}
    echo -e "Description: (empty line finish)" >> ${CONTROL_FILE}
    echo
    autoedit_control_file
}


function autoedit_control_file()   
{
    local warning
    local section
    local delete_lines
    local section_key
    local section_val
    local input_read

    warning=""
    input_read=""
    section="Package"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z $(echo -e "${input_read}" | sed -e "/[^a-zA-Z0-9-]/d") ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Version"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z "${input_read}" ]] \
            || [[ ! "${input_read}" =~ ^[0-9]+\.[0-9]+([.]+[0-9]+)?([-]+.+)?$ ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Section"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" ; [[ -z "${input_read}" ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE} 

    warning=""
    input_read=""
    section="Priority"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" ; [[ -z "${input_read}" ]] || break ;  done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Architecture"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z "${input_read}" ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Depends"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    read -r -e -i "${section_val}" -p "${section_key} >> " input_read 
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Description"
    OLDIFS=${IFS}
    IFS=$'\n'
    for ln in $( sed -ne "/^${section}:/,/^$/p" ${CONTROL_FILE} ) ; do
        if [[ -n $(echo -e "${ln}" | sed -e "/^${section}:.*/!d") ]] ; then
            section_key=$(echo -e "${ln}" \
                | sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|" )
            section_val=$(echo -e "${ln}" \
                | sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|" )
        else
            section_key=""
            section_val=$(echo -e "${ln}" |  sed -e "s|\(.*$\)|\1|")
        fi
        section_val=$(echo -e "${section_val}" | sed -e "s|^ *\(.\+\)|\1|" )


        if [[ -n $delete_lines ]] ; then
                input_read=""
        else
            read -r -e -i "${section_val}" -p "${section_key} >> " input_read 
            input_read=$(echo -e "$input_read" | sed -e "s|^ *||g"  )
        fi

        if [[ -n "${input_read}" ]] ; then
            sed -i -e "s|\(^${section_key}\)\( *\)\(${section_val}\)|\1 ${input_read}|" ${CONTROL_FILE} 
        else
            sed -i -e "/^.*${section_val}$/d" ${CONTROL_FILE}
            delete_lines="y"
        fi
    done
    if [[ -z "$delete_lines" ]] ; then
        while : ; do
            read -r -e -p " >> " input_read
            input_read=$(echo ${input_read} | sed -e "s|^ *||"  )
            echo -e " ${input_read}" >> ${CONTROL_FILE}
            [[ -n "${input_read}" ]] || break
        done
    fi
    IFS=$OLDIFS
    echo
    #read_control_file 
    #edit_file ${CONTROL_FILE}
}


function read_control_file()
{
    check_control_file

    # Taking vars from control file
    PACKAGE=$(sed -e '/^Package/!d' -e 's/Package:[[:space:]]\+\([[:alnum:]]\+\)\.*/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    ARCH=$(sed -e '/^Architecture/!d' -e 's/Architecture:[[:space:]]\+\([[:alnum:]]\+\)/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
            BUILD_DEST_DIR="${PACKAGE}_${VERSION}_${ARCH}"

    BUILD_PREFIX="/${BUILD_DEST_DIR}"

    echo -e "********** control file *************"
    echo 
    cat ${CONTROL_FILE}
    echo 
    echo -e "*************************************"
    echo
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: debian package root directory:"
    echo -e "    ./$(basename ${BUILD_PREFIX})"
    echo
}


function edit_file()
{
    local file="$1"
    local input_read=''

    #echo -ne "Do you want to edit \"$file\" file (a/e/N)?"

    local default_editor=$(realpath /usr/bin/editor | xargs basename  )
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Do you want to edit \"$file\" file?"
    echo -ne "[autoedit(a), ${default_editor}(e), not(N)]:"

    read -sn1 input_read
    echo
    case $input_read in
        [Aa])
            autoedit_control_file
            read_control_file && edit_file ${file}
            ;;
        [Ee])
            nano "${file}"
            read_control_file && edit_file ${file}
            ;;
        *)
            echo -e "${SCRIPT_NAME}: Skiping edit $file file "
            ;;
    esac
    echo
}


function change_version()
{
    ## Change version of files than have the next format inside:
    ## Version: X.X[.X][-something]
    ## With or without # initial comment character
    ## Usually:
    ##         "control" file	
    ##         "README" file
    ##         "Makefile"

    local warning=""
    echo
    VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
                -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    while [[ -z ${VERSION} ]] || [[ ! ${VERSION} =~ ^[0-9]+\.[0-9]+([.]+[0-9]+)?([-]+.+)?$ ]]  ; do
        echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Please, set version${warning}"
        new_version=''
        sed "/^Version:.*/!d" ${CONTROL_FILE}
        read -p ">> " new_version ; warning="${warning}!!"
        sed -i -e "s/\(^Version:\)\( *\)\(.*\)/\1 ${new_version}/" ${CONTROL_FILE}
        VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
                -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    done

    local files_w_version=$(find -L ${SOURCE_DIR} -type f -not -name "control" \( -exec grep -l -e "^#\{0,1\}[[:space:]]*Version:[[:space:]]\+[[:digit:]]\+.*" {} \; \) )
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Changing the next files to \"Version: ${VERSION}\""
    for file in ${files_w_version} ; do
        echo -ne "from $(sed -e "/Version:[[:space:]]\+[[:digit:]]\+.*/!d" -e "s/^#* *\(Version:.*\)$/\1/" ${file})"
        sed  -i -e "s|\(Version:[[:space:]]\+\)\([[:digit:]]\+.*\)|\1${VERSION}|g" ${file}
        echo -e " to  $(sed -e "/Version:[[:space:]]\+[[:digit:]]\+.*/!d" -e "s/^#* *\(Version:.*\)$/\1/" ${file})\n    ${file}"
    done

}


function prepare()
{
    local input_read=${1}
    local mssg=$( cat << EOF
${GREEN}${SCRIPT_NAME}${NORMAL}: Do you want to PREPARE the debian package root directori
and files tree using "Makefile" and "control" file? [y/N]:
EOF
)
    echo
    if [[ ! "${input_read}" ]] ; then
        echo -ne "${mssg}"
        read -sn1 input_read
        echo
    fi
    echo
    if [[ "$input_read" =~ ^[Yy]$ ]] ; then
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Preparing files tree to build the package"
        [[ -e .debian/preinst ]] && chmod +x .debian/preinst
        [[ -e .debian/prerm ]] && chmod +x .debian/prerm
        [[ -e .debian/postinst ]] && chmod +x .debian/postinst
        [[ -e .debian/postrm ]] && chmod +x .debian/postrm
        mkdir -p "./${BUILD_DEST_DIR}/DEBIAN"
        cp ./debian/* ./${BUILD_DEST_DIR}/DEBIAN/
        cd "${SOURCE_DIR}${SRC}"
        echo -e "${SOURCE_DIR}${SRC}"
        echo
        if [[ -e ./Makefile ]]; then
            make  "BUILD=${WORKING_DIR}${BUILD_PREFIX}" install
        else
            echo -e "Error: Makefile does not exist"
            exit 1 
        fi
    else
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Exiting"
        exit 0
    fi
    echo
}


function create()
{
    local input_read=${1}
    echo
    if [[ ! "${input_read}" ]] ; then
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Do you want to BUILD"
        echo -ne "the package ${BUILD_DEST_DIR}.deb? [y/N]:"
        read -sn1 input_read
        echo
    fi

    if [[ $input_read =~ ^[Yy]$ ]] ; then
        echo
        cd "${WORKING_DIR}"
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Building the package"
        echo -e "    ${BUILD_DEST_DIR}.deb"
        fakeroot dpkg-deb --build "${BUILD_DEST_DIR}" \
                    || (echo -e "${RED}${SCRIPT_NAME}${NORMAL}: Error building package" && exit 1)
    else
        echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Exiting"
        exit 0
    fi
    echo
}


function remove()
{
    cd "${WORKING_DIR}"
    echo -e "${GREEN}${SCRIPT_NAME}${NORMAL}: Removing  debian package root directory and .deb package"
    read_control_file  > /dev/null
    ( [[ -d ./${BUILD_DEST_DIR} ]] && rm -fR "./${BUILD_DEST_DIR}" \
        && echo -e "    Removing ${BUILD_DEST_DIR} directory" ) \
        || echo -e "${RED}${SCRIPT_NAME}${NORMAL}: ./${BUILD_DEST_DIR} does not exist"
    ( [[ -e ./${BUILD_DEST_DIR}.deb ]] && rm "./${BUILD_DEST_DIR}.deb" \
        && echo -e "    Removing ${BUILD_DEST_DIR}.deb package" ) \
        || echo -e "${RED}${SCRIPT_NAME}${NORMAL}: ./${BUILD_DEST_DIR}.deb does not exist"
}


function clean()
{
    clean_target=$(make -npq : 2> /dev/null \
                | awk -v RS= -F: '$1 ~ /^[^#%.]+$/ { print $1 }' | grep clean)

    if [[ -n "${clean_target}" ]] ; then
        make  "BUILD=${WORKING_DIR}${BUILD_PREFIX}" clean
    else
        echo -e "No existe el objetivo \"clean\" en este Makefile"
    fi
}



function mssg_help()
{
   ( cat <<EOF
Description: $(basename $0) builds a .deb package from sources.

Usage:
  $(basename $0) [-h] [-y] [-c -r -d] <SOURCE_DIRECTORY>  [<working_dir>]

<SOURCE_DIRECTORY>
        Containing at least a "source" directory with its make files

<WORKING_DIRECTORY>
        The directory where the DEB package will be created.
        If a "debian" directory, with its "control" file does not exist
        the script will create.
            If a <WORKING_DIRECTORY>  is not passsed as argument
        it will use the current working directory.

Options:
  -h  Shows this message.
  -y  It assume YES for all questions: prepare, build and install.
  -c  Execute clean from sources Makefile .
  -r  Removes the tree root directories of DEB package.

A source directory is mandatory and a "Makefile" that
recreates the files tree in the package root directory.

A "debian" directory is necessary, with a "control" file
and optionally postinst, postrm, etc files, which content
will be copied to "DEBIAN" folder in the package root
directory named "Package_Version_Architecture" obtained
from "control" file.

The deb package will be named as package root directory 
with .deb extension:
  Package_Version_Architecture.deb

EOF
) | less
}

OPTIONS=$(getopt  -o "hycr" -n "${SCRIPT_NAME}" -- "$@")

if [ $? != 0 ] ; then
  exit 1 ;
fi

eval set -- "$OPTIONS"

while true ; do 
    case $1 in 
            -y)
                GLOBAL_YES="y"
                shift
                ;;
            -h)
                mssg_help
                shift
                exit 0
                ;;
            -r)
                REMOVE="Y"
                EXIT="exit 0"
                shift
                ;;
            -c)
                CLEAN="Y"
                EXIT="exit 0"
                shift
                ;;
            --)
                check_user ; shift

                if [[ -n $1 ]] ; then
                    SOURCE_DIR=$(realpath ${1})
                    shift
                else
                    SOURCE_DIR=$(realpath $PWD)
                fi

                if [[ -n "${1}" ]] ; then
                    WD=$(realpath ${1})
                    shift
                else
                    WD=${PWD}
                    echo -ne "${RED}${SCRIPT_NAME}${NORMAL}: "
                    echo -e "Argument <WORKING_DIRECTORY> is not passed"
                    echo -ne "${RED}${SCRIPT_NAME}${NORMAL}: "
                    echo -e "It will use current directory as project root directory"
                    echo -e "    ${WD}"

                fi

                set_working_directory ${WD}

                [[ -n "${REMOVE}" ]] && remove
                [[ -n "${CLEAN}" ]] && clean
                ${EXIT}
                check_sources
                read_control_file && edit_file ${CONTROL_FILE}
                change_version
                prepare 
                create 

                echo
                break
                ;;
            *)
                shift
                exit 1
                ;;
    esac
done

exit 0

