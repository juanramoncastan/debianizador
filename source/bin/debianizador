#!/bin/bash


# debianizador 
# Version: 1.4
# Author: monon



SRC="/source"
CONTROL_FILE="./debian/control"
WORKING_DIR=""
BUILD_PREFIX=""
BUILD_DEST_DIR=""

EXIT=""
GLOBAL_YES=""
CLEAN=""
REMOVE=""


function check_user()
{
    echo -e "User: ${USER}"
    if [[ ${UID} = "0" ]] ; then 
        echo -e "Warning!!!!\nRun \"debianizador\" script as normal user"
    fi
}


function set_working_directory()
{
    echo
    WORKING_DIR=${1}
    if [[ -n "${WORKING_DIR}" ]] ; then
        if [[ -d "${WORKING_DIR}" ]] ; then
            echo -e "Working directory:\n  ${WORKING_DIR}"
            cd ${WORKING_DIR}
        else
            echo "The directory:"
            echo "${WORKING_DIR}"
            echo "does not exist"
            exit 1
        fi
    else
        echo "Warnnig!  $(basename $0) "
        echo "It is mandatory directory with a project and a DEBIAN folder"
        echo "run $(basename $0) -h to show help message"
        exit 1
    fi
}

# if SOURCE exists
function check_sources()
{
    echo
    if [[ -e "${SOURCE_DIR}${SRC}"  ]] ; then
        echo -e "Source directory:\n  ${SOURCE_DIR}${SRC}"
    else
        echo -e "Source directory \"${SOURCE_DIR}${SRC}\" does not exist"
        exit 2
    fi
}


function check_control_file()
{
    local input_read
    echo
    echo -e "Checking control file"
    ## Checking if /debian folder is in the working directory
    if [[ ! -d "./debian" ]] ; then
        echo
        echo "A \"debian\" folder with at least a control file is mandatory"
        echo -ne "Do you want to create \"debian\" folder? (y/N)"
        input_read=''
        read -sn1 input_read
        echo
        if [[ "${input_read}" =~ ^[Yy]$ ]] ; then
            mkdir -p "${WORKING_DIR}/debian"
        else
            echo "Exiting"
            exit 1
        fi
    fi
    
    ## Checking if control file is into /working_directory/debian folder
    if [[ ! -e "${CONTROL_FILE}" ]]  || [[ -z $(cat "${CONTROL_FILE}") ]] ; then
        echo
        echo "Error: You must to create a control file"
        echo -ne "Do you want to create a \"control\" file? (y/N)"
        input_read=''
        read -sn1 input_read
        echo
        ## If control file does not exist or it is emmpty it will be created
        if [[ "${input_read}" =~ ^[Yy]$ ]] ; then
            create_control_file
        else
            echo "sdfsdfs"
            exit 1
        fi
    else  ## If control file exists it will be formated
        echo
        # Formating control file
        (sed -i -e "/^[[:space:]]*$/d" \
        -e "/Description:/,/^$/ {s# *\([[:alnum:]]\+\)# \1#}" \
        -e "s/^ *\(Package:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Version:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Section:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Priority:\) *\([[:alnum:]]*\)/\1 \2/"  \
        -e "s/^ *\(Architecture:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\(Depends:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e "s/^ *\([[:alnum:]]\+:\) *\([[:alnum:]]*\)/\1 \2/" \
        -e '$a\' ${CONTROL_FILE} \
        && ([[ -s "${CONTROL_FILE}"  ]] && echo "Formating \"control\" file")) \
        || (echo "Error formating \"control\" file" && exit 1)
    fi
}


function create_control_file()
{
    local package_name=$(basename "${SOURCE_DIR}")
    touch "${CONTROL_FILE}"
    chmod 664 "${CONTROL_FILE}"
    echo -e "Package: ${package_name}" >> ${CONTROL_FILE}
    echo -e "Version: (i.e. 1.0-1)" >> ${CONTROL_FILE}
    echo -e "Section: (admin|..|devel|games|sound|...)"  >> ${CONTROL_FILE}
    echo -e "Priority: (required|important|standart|optional|extra)" >> ${CONTROL_FILE}
    echo -e "Architecture: (all|i386|amd64|...)" >> ${CONTROL_FILE}
    echo -e "Depends: (foo (>= 1.5.0), bar | baz, qux)" >> ${CONTROL_FILE}
    echo -e "Maintainer: Juan Ramon Castan" >> ${CONTROL_FILE}
    echo -e "Description: (empty line finish)" >> ${CONTROL_FILE}
    echo
    autoedit_control_file
}


function autoedit_control_file()   
{
    local warning
    local section
    local delete_lines
    local section_key
    local section_val
    local input_read
    
    warning=""
    input_read=""
    section="Package"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z $(echo "${input_read}" | sed -e "/[^a-zA-Z0-9-]/d") ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}
    
    warning=""
    input_read=""
    section="Version"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z "${input_read}" ]] \
            || [[ ! "${input_read}" =~ ^[0-9]+\.[0-9]+([.]+[0-9]+)?([-]+.+)?$ ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}
    
    warning=""
    input_read=""
    section="Section"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" ; [[ -z "${input_read}" ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE} 

    warning=""
    input_read=""
    section="Priority"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" ; [[ -z "${input_read}" ]] || break ;  done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}

    warning=""
    input_read=""
    section="Architecture"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    while : ; do read -r -e -i "${section_val}${warning}" -p "${section_key} >> " \
            input_read ; warning="${warning}!" \
            ; [[ -z "${input_read}" ]] || break ; done
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}
    
    warning=""
    input_read=""
    section="Depends"
    section_key=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|"   ${CONTROL_FILE})
    section_val=$(sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|"   ${CONTROL_FILE})
    read -r -e -i "${section_val}" -p "${section_key} >> " input_read 
    sed -i -e "s/\(^${section}:\)\( *\)\(.*\)/\1 ${input_read}/" ${CONTROL_FILE}
    
    warning=""
    input_read=""
    section="Description"
    OLDIFS=${IFS}
    IFS=$'\n'
    for ln in $( sed -ne "/^${section}:/,/^$/p" ${CONTROL_FILE} ) ; do
        if [[ -n $(echo -e "${ln}" | sed -e "/^${section}:.*/!d") ]] ; then
            section_key=$(echo -e "${ln}" \
                | sed -e "/^${section}:.*/!d" -e "s|\(^${section}:\)\(.*\)|\1|" )
            section_val=$(echo -e "${ln}" \
                | sed -e "/^${section}:.*/!d" -e "s|\(^${section}: *\)\(.*\)|\2|" )
        else
            section_key=""
            section_val=$(echo -e "${ln}" |  sed -e "s|\(.*$\)|\1|")
        fi
        section_val=$(echo "${section_val}" | sed -e "s|^ *\(.\+\)|\1|" )


        if [[ -n $delete_lines ]] ; then
                input_read=""
        else
            read -r -e -i "${section_val}" -p "${section_key} >> " input_read 
            input_read=$(echo "$input_read" | sed -e "s|^ *||g"  )
        fi
        
        if [[ -n "${input_read}" ]] ; then
            sed -i -e "s|\(^${section_key}\)\( *\)\(${section_val}\)|\1 ${input_read}|" ${CONTROL_FILE} 
        else
            sed -i -e "/^.*${section_val}$/d" ${CONTROL_FILE}
            delete_lines="y"
        fi
    done
    if [[ -z "$delete_lines" ]] ; then
        while : ; do
            read -r -e -p " >> " input_read
            input_read=$(echo ${input_read} | sed -e "s|^ *||"  )
            echo " ${input_read}" >> ${CONTROL_FILE}
            [[ -n "${input_read}" ]] || break
        done
    fi
    IFS=$OLDIFS
    echo
    #read_control_file 
    #edit_file ${CONTROL_FILE}
}


function read_control_file()
{
    check_control_file

    # Taking vars from control file
    PACKAGE=$(sed -e '/^Package/!d' -e 's/Package:[[:space:]]\+\([[:alnum:]]\+\)\.*/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    ARCH=$(sed -e '/^Architecture/!d' -e 's/Architecture:[[:space:]]\+\([[:alnum:]]\+\)/\1/' \
            -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
            
    BUILD_DEST_DIR="${PACKAGE}_${VERSION}_${ARCH}"
    BUILD_PREFIX="/${BUILD_DEST_DIR}"
    # Show control file
    echo "********** control file *************"
    cat ${CONTROL_FILE}
    echo "*************************************"
    echo
    echo -e "debian package root directory:"
    echo -e "\t$(basename ${BUILD_PREFIX})"
    echo
}


function edit_file()
{
    local file="$1"
    local input_read=''
    echo -ne "Do you want to edit \"$file\" file (a/e/N)?"
    read -sn1 input_read
    echo
    case $input_read in
        [Aa])
            autoedit_control_file
            read_control_file && edit_file ${file}
            ;;
        [Ee])
            nano "${file}"
            read_control_file && edit_file ${file}
            ;;
        *)
            echo "Skiping edit $file file "
            ;;
    esac
    echo
}


function change_version()
{
    
    ## Change version of files than have the next format inside:
    ## Version: X.X[.X][-something]
    ## With or without # initial comment character
    ## Usually:
    ##         "control" file
    ##         "README" file
    ##         "Makefile"
    
    local warning=""
    VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
                -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    while [[ -z ${VERSION} ]] || [[ ! ${VERSION} =~ ^[0-9]+\.[0-9]+([.]+[0-9]+)?([-]+.+)?$ ]]  ; do
        echo -e "Please, set version${warning}"
        new_version=''
        sed "/^Version:.*/!d" ${CONTROL_FILE}
        read -p ">> " new_version ; warning="${warning}!!"
        sed -i -e "s/\(^Version:\)\( *\)\(.*\)/\1 ${new_version}/" ${CONTROL_FILE}
        VERSION=$(sed -e '/^Version/!d' -e 's/Version:[[:space:]]\+\([[:alnum:]]\+.*\)/\1/' \
                -e "s/[[:space:]]\+//g" ${CONTROL_FILE})
    done

    local files_w_version=$(find -L ${SOURCE_DIR} -type f -not -name "control" \(-exec grep -l -e "^#\{0,1\}[[:space:]]*Version:[[:space:]]\+[[:digit:]]\+.*" {} \; \) )
    echo -e "Changing the next files to \"Version: ${VERSION}\""
    for file in ${files_w_version} ; do
        echo -ne "From $(sed -e "/Version:[[:space:]]\+[[:digit:]]\+.*/!d" -e "s/^#* *\(Version:.*\)$/\1/" ${file})"
        sed  -i -e "s|\(Version:[[:space:]]\+\)\([[:digit:]]\+.*\)|\1${VERSION}|g" ${file}
        echo -e " to Version: $(sed -e "/Version:[[:space:]]\+[[:digit:]]\+.*/!d" -e "s/^#* *\(Version:.*\)$/\1/" ${file})\n\t${file}"
    done
    echo
}


function prepare()
{
    local input_read=${1}
    local mssg=$( cat << EOF
Do you want to PREPARE the files tree of DEB package
using "Makefile" and "control" file (y/N)?
EOF
)
    if [[ ! "${input_read}" ]] ; then
        echo -ne "${mssg}"
        read -sn1 input_read
        echo
    fi
    if [[ "$input_read" =~ ^[Yy]$ ]] ; then
        echo "Preparing files tree to build the package"
        [[ -e .debian/preinst ]] && chmod +x .debian/preinst
        [[ -e .debian/prerm ]] && chmod +x .debian/prerm
        [[ -e .debian/postinst ]] && chmod +x .debian/postinst
        [[ -e .debian/postrm ]] && chmod +x .debian/postrm
        mkdir -p "./${BUILD_DEST_DIR}/DEBIAN"
        cp ./debian/* ./${BUILD_DEST_DIR}/DEBIAN/
        cd "${SOURCE_DIR}${SRC}"
        echo "${SOURCE_DIR}${SRC}"
        echo
        if [[ -e ./Makefile ]]; then
            make  "BUILD=${WORKING_DIR}${BUILD_PREFIX}" install )
        else
            exit 1 
        fi
    else
        exit 0
    fi
    echo
}


function create()
{
    local input_read=${1}
    if [[ ! "${input_read}" ]] ; then
        echo -ne "Do you want to BUILD the package ${BUILD_DEST_DIR}.deb (y/N)?"
        read -sn1 input_read
        echo
    fi
    
    if [[ $input_read =~ ^[Yy]$ ]] ; then
        echo
        cd "${WORKING_DIR}"
        echo "Building the package"
        echo "${BUILD_DEST_DIR}"
        fakeroot dpkg-deb --build "${BUILD_DEST_DIR}" || exit 1
    else
        echo "Skiping package built"
        exit 0
    fi
    echo
}


function remove()
{
    cd "${WORKING_DIR}"
    echo -e "Removing debian package root directory and package"
    read_control_file  > /dev/null
    ( [[ -d ./${BUILD_DEST_DIR} ]] && rm -fR "./${BUILD_DEST_DIR}" \
            && echo -e "Removing ${BUILD_DEST_DIR} directory" ) \
            || echo "./${BUILD_DEST_DIR} does not exist"
    ( [[ -e ./${BUILD_DEST_DIR}.deb ]] && rm "./${BUILD_DEST_DIR}.deb" \
            && echo -e "Removing ${BUILD_DEST_DIR}.deb package" ) \
            || echo "./${BUILD_DEST_DIR}.deb does not exist"
}


function clean()
{
    clean_target=$(make -npq : 2> /dev/null \
                | awk -v RS= -F: '$1 ~ /^[^#%.]+$/ { print $1 }' | grep clean)
                
    if [[ -n "${clean_target}" ]] ; then
        make  "BUILD=${WORKING_DIR}${BUILD_PREFIX}" clean
    else
        echo "No existe el objetivo \"clean\" en este Makefile"
    fi
    
}



function mssg_help()
{
   ( cat <<EOF
Description: $(basename $0) builds a .deb package from sources.

Usage:
  $(basename $0) [-h] [-y] [-c -r -d] <SOURCE_DIRECTORY>  [<working_dir>]

<SOURCE_DIRECTORY>
        Containing at least a "source" directory with its make files

<WORKING_DIRECTORY>
        The directory where the DEB package will be created.
        If a "debian" directory, with its "control" file does not exist
        the script will create.
        
        If a <WORKING_DIRECTORY>  is not passsed as argument
        it will use the current working directory.

Options:
  -h  Shows this message.
  -y  It assume YES for all questions: prepare, build and install.
  -c  Execute clean from sources Makefile .
  -r  Removes the tree root directories of DEB package.

A source directory is mandatory and a "Makefile" that
recreates the files tree in the package root directory.

A "debian" directory is necessary, with a "control" file
and optionally postinst, postrm, etc files, which content
will be copied to "DEBIAN" folder in the package root
directory named "Package_Version_Architecture" obtained
from "control" file.

The deb package will be named as package root directory 
with .deb extension:
  Package_Version_Architecture.deb

EOF
) | less
}

OPTIONS=$(getopt  -o "hycr" -n '$0' -- "$@")

if [ $? != 0 ] ; then
  exit 1 ;
fi

eval set -- "$OPTIONS"

while true ; do 
    case $1 in 
            -y)
                GLOBAL_YES="y"
                shift
                ;;
            -h)
                mssg_help
                shift
                exit 0
                ;;
            -r)
                REMOVE="Y"
                EXIT="exit 0"
                shift
                ;;
            -c)
                CLEAN="Y"
                EXIT="exit 0"
                shift
                ;;
            --)
                check_user ; shift
                
                if [[ -n $1 ]] ; then
                    SOURCE_DIR=$(realpath ${1})
                    shift
                fi
                
                check_sources

                if [[ -n "${1}" ]] ; then
                    WD=$(realpath ${1})
                    shift
                else
                    WD=${PWD}
                    echo -e "Warning!"
                    echo -e "Argument <WORKING_DIRECTORY> is not passed"
                    echo -e "It will use current directory"
                    echo -e "\"${WD}\""
                    echo -e "as project root directory"
                fi
                
                set_working_directory ${WD}
                [[ -n "${REMOVE}" ]] && remove
                [[ -n "${CLEAN}" ]] && clean
                ${EXIT}
                read_control_file && edit_file ${CONTROL_FILE}
                change_version
                prepare 
                create 
                
                echo
                break
                ;;
            *)
                shift
                exit 1
                ;;
    esac
done

exit 0

